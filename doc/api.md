# 文档
clone主要用来进行深拷贝，为什么深拷贝那么简单，还要搞个库？因为深拷贝确实不简单

## clone
通过递归方式实现的深拷贝

支持对象和数组的深拷贝，其他类型数据会浅拷贝；支持父子元素循环引用

函数参数和返回值

- param {\*} x 要进行深拷贝的数据
- return {\*} 如果x为对象或数组，则为x的副本，否则会直接返回

举个例子（要包含代码用例）

```js
clone(1) // 1

clone([]) // []
clone([1, 2, 3]) // 深拷贝的 [1, 2, 3]
clone([1, [2, [3]]]) // 深拷贝的 [1, [2, [3]]]

clone({}) // {}
clone({a: 1, b: 1}) // 深拷贝的 {a: 1, b: 1}
clone({a1: 1, a2: {b1: 1, b2: 2}}) // 深拷贝的 {a1: 1, a2: {b1: 1, b2: 2}}

var a = {a1: 1};
a.a2 = a;
clone(a) // 深拷贝的 {a1: 1, a2: a} 支持父子循环引用
```

## cloneJSON
通过`JSON.parse(JSON.stringify(x))`方式实现的深拷贝

支持基本类型，对象和数组的深拷贝；不支持循环引用；支持默认值

函数参数和返回值

- param {\*} x 要进行深拷贝的数据
- param {\*} [errOrDef=true] true代表报错是终止程序，其他值则代表报错时提供默认值
- return {\*} 如果x为对象或数组，则为x的副本，否则会直接返回

举个例子（要包含代码用例）

```js
cloneJSON(1) // 1

cloneJSON([]) // []
cloneJSON([1, 2, 3]) // 深拷贝的 [1, 2, 3]
cloneJSON([1, [2, [3]]]) // 深拷贝的 [1, [2, [3]]]

cloneJSON({}) // {}
cloneJSON({a: 1, b: 1}) // 深拷贝的 {a: 1, b: 1}
cloneJSON({a1: 1, a2: {b1: 1, b2: 2}}) // 深拷贝的 {a1: 1, a2: {b1: 1, b2: 2}}

var a = {a1: 1};
a.a2 = a;
cloneJSON(a) // 循环引用会报错
cloneJSON(a, {}) // {} 提供默认值，则会返回默认值，不在报错
```


## cloneLoop
通过循环方式实现的深拷贝，如果数据量很大或层级很深，递归的方式会栈溢出，循环的方式则不会

支持对象和数组的深拷贝，其他类型数据会浅拷贝；支持父子元素循环引用

函数参数和返回值

- param {\*} x 要进行深拷贝的数据
- return {\*} 如果x为对象或数组，则为x的副本，否则会直接返回

举个例子（要包含代码用例）

```js
cloneLoop(1) // 1

cloneLoop([]) // []
cloneLoop([1, 2, 3]) // 深拷贝的 [1, 2, 3]
cloneLoop([1, [2, [3]]]) // 深拷贝的 [1, [2, [3]]]

cloneLoop({}) // {}
cloneLoop({a: 1, b: 1}) // 深拷贝的 {a: 1, b: 1}
cloneLoop({a1: 1, a2: {b1: 1, b2: 2}}) // 深拷贝的 {a1: 1, a2: {b1: 1, b2: 2}}

var a = {a1: 1};
a.a2 = a;
cloneLoop(a) // 深拷贝的 {a1: 1, a2: a} 支持父子循环引用
```

## cloneForce
通过循环方式实现的深拷贝，并且能够支持任意循环引用，保留引用关系

支持对象和数组的深拷贝，其他类型数据会浅拷贝

最大支持2^32-1各对象的深拷贝，因为唯一数组会越界，当数量超过2000个时，会有明显延时（1s）

函数参数和返回值

- param {\*} x 要进行深拷贝的数据
- return {\*} 如果x为对象或数组，则为x的副本，否则会直接返回

举个例子（要包含代码用例）

```js
cloneForce(1) // 1

cloneForce([]) // []
cloneForce([1, 2, 3]) // 深拷贝的 [1, 2, 3]
cloneForce([1, [2, [3]]]) // 深拷贝的 [1, [2, [3]]]

cloneForce({}) // {}
cloneForce({a: 1, b: 1}) // 深拷贝的 {a: 1, b: 1}
cloneForce({a1: 1, a2: {b1: 1, b2: 2}}) // 深拷贝的 {a1: 1, a2: {b1: 1, b2: 2}}

var a = {a1: {b1: {c1: 1}}};
a.a1.b1.c2 = a;
cloneForce(a) // 深拷贝的 {a1: {b1: {c1: 1, c2: a}}} 支持任意循环引用
```
