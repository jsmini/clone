# 文档

clone主要用来进行深拷贝，为什么深拷贝那么简单，还要搞个库？因为深拷贝确实不简单

## clone

通过递归方式实现的深拷贝

支持对象和数组的深拷贝，其他类型数据会浅拷贝；支持父子元素循环引用

函数参数和返回值

- param {\*} x 要进行深拷贝的数据
- return {\*} 如果x为对象或数组，则为x的副本，否则会直接返回

举个例子（要包含代码用例）

```js
clone(1); // 1

clone([]); // []
clone([1, 2, 3]); // 深拷贝的 [1, 2, 3]
clone([1, [2, [3]]]); // 深拷贝的 [1, [2, [3]]]

clone({}); // {}
clone({ a: 1, b: 1 }); // 深拷贝的 {a: 1, b: 1}
clone({ a1: 1, a2: { b1: 1, b2: 2 } }); // 深拷贝的 {a1: 1, a2: {b1: 1, b2: 2}}

var a = { a1: 1 };
a.a2 = a;
clone(a); // 深拷贝的 {a1: 1, a2: a} 支持父子循环引用
```

## cloneJSON

通过`JSON.parse(JSON.stringify(x))`方式实现的深拷贝

支持基本类型，对象和数组的深拷贝；不支持循环引用；支持默认值

函数参数和返回值

- param {\*} x 要进行深拷贝的数据
- param {\*} [errOrDef=true] true代表报错是终止程序，其他值则代表报错时提供默认值
- return {\*} 如果x为对象或数组，则为x的副本，否则会直接返回

举个例子（要包含代码用例）

```js
cloneJSON(1); // 1

cloneJSON([]); // []
cloneJSON([1, 2, 3]); // 深拷贝的 [1, 2, 3]
cloneJSON([1, [2, [3]]]); // 深拷贝的 [1, [2, [3]]]

cloneJSON({}); // {}
cloneJSON({ a: 1, b: 1 }); // 深拷贝的 {a: 1, b: 1}
cloneJSON({ a1: 1, a2: { b1: 1, b2: 2 } }); // 深拷贝的 {a1: 1, a2: {b1: 1, b2: 2}}

var a = { a1: 1 };
a.a2 = a;
cloneJSON(a); // 循环引用会报错
cloneJSON(a, {}); // {} 提供默认值，则会返回默认值，不在报错
```

## cloneLoop

通过循环方式实现的深拷贝，如果数据量很大或层级很深，递归的方式会栈溢出，循环的方式则不会

支持对象和数组的深拷贝，其他类型数据会浅拷贝；支持父子元素循环引用

函数参数和返回值

- param {\*} x 要进行深拷贝的数据
- return {\*} 如果x为对象或数组，则为x的副本，否则会直接返回

举个例子（要包含代码用例）

```js
cloneLoop(1); // 1

cloneLoop([]); // []
cloneLoop([1, 2, 3]); // 深拷贝的 [1, 2, 3]
cloneLoop([1, [2, [3]]]); // 深拷贝的 [1, [2, [3]]]

cloneLoop({}); // {}
cloneLoop({ a: 1, b: 1 }); // 深拷贝的 {a: 1, b: 1}
cloneLoop({ a1: 1, a2: { b1: 1, b2: 2 } }); // 深拷贝的 {a1: 1, a2: {b1: 1, b2: 2}}

var a = { a1: 1 };
a.a2 = a;
cloneLoop(a); // 深拷贝的 {a1: 1, a2: a} 支持父子循环引用
```

## cloneForce

通过循环方式实现的深拷贝，并且能够支持任意循环引用，保留引用关系

支持对象和数组的深拷贝，其他类型数据会浅拷贝

最大支持2^32-1各对象的深拷贝，因为唯一数组会越界，当数量超过2000个时，会有明显延时（1s）

函数参数和返回值

- param {\*} x 要进行深拷贝的数据
- return {\*} 如果x为对象或数组，则为x的副本，否则会直接返回

举个例子（要包含代码用例）

```js
cloneForce(1); // 1

cloneForce([]); // []
cloneForce([1, 2, 3]); // 深拷贝的 [1, 2, 3]
cloneForce([1, [2, [3]]]); // 深拷贝的 [1, [2, [3]]]

cloneForce({}); // {}
cloneForce({ a: 1, b: 1 }); // 深拷贝的 {a: 1, b: 1}
cloneForce({ a1: 1, a2: { b1: 1, b2: 2 } }); // 深拷贝的 {a1: 1, a2: {b1: 1, b2: 2}}

var a = { a1: { b1: { c1: 1 } } };
a.a1.b1.c2 = a;
cloneForce(a); // 深拷贝的 {a1: {b1: {c1: 1, c2: a}}} 支持任意循环引用
```
